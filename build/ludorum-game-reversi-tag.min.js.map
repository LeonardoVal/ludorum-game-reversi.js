{"version":3,"sources":["../src/__prologue__.js","../src/Reversi.js","../src/Othello.js","../src/heuristics.js","../src/__epilogue__.js"],"names":["__init__","base","Sermat","ludorum","cache","declare","obj","raise","copy","raiseIf","Iterable","iterable","Game","Checkerboard","utils","CheckerboardFromString","exports","players","UserInterface","__package__","__name__","__dependencies__","__SERMAT__","include","Reversi","name","constructor","activePlayer","board","call","this","makeBoard","apply","dual makeBoard","rows","columns","string","isNaN","lines","cols","key","result","map","line","toArray","length","__MOVE_REGEXPS__","Black","White","dual boardCenter","w","width","h","height","moves","player","hasOwnProperty","coords","regexps","_moves","boardCenter","filter","coord","square","id","forEach","regexp","asString","replace","m","i","charAt","push","arguments","validMoves","allMoves","join","indexOf","next","haps","update","JSON","stringify","piece","valid","clone","move","__place__","walks","DIRECTIONS","EVERY","walk","match","exec","substr","slice","opponent","weight","W","B","res_b","sum","zerosumResult","resultBounds","squareCount","static __SERMAT__","identifier","serializer","games","Othello","activePlayers","heuristics","heuristicFromWeights","weights","weightCount","weightSum","Math","abs","heuristic","game","weightedSum","heuristicFromSymmetricWeights","ceil","range","column","left","right","concat","reverse","flatten","pieceRatio","playerPieceCount","opponentPieceCount","sq","mobilityRatio","playerMoves","opponentMoves","playerMoveCount","opponentMoveCount","defaultHeuristic","HeuristicPlayer","composite"],"mappings":"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","file":"ludorum-game-reversi-tag.min.js","sourcesContent":["/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat, ludorum) { \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\tobj = base.obj,\n\t\tcopy = base.copy,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tIterable = base.Iterable,\n\t\titerable = base.iterable,\n\t\tGame = ludorum.Game,\n\t\tCheckerboard = ludorum.utils.Checkerboard,\n\t\tCheckerboardFromString = ludorum.utils.CheckerboardFromString,\n\t\tUserInterface = ludorum.players.UserInterface;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t__package__: 'ludorum-game-reversi',\n\t\t__name__: 'ludorum_game_reversi',\n\t\t__init__: __init__,\n\t\t__dependencies__: [base, Sermat, ludorum],\n\t\t__SERMAT__: { include: [base, ludorum] }\n\t};\n","/** # Reversi\n\nImplementation of [Reversi](http://en.wikipedia.org/wiki/Reversi) for Ludorum.\n*/\nvar Reversi = exports.Reversi = declare(Game, {\n\tname: 'Reversi',\n\n\t/** The constructor takes the `activePlayer` (`\"Black\"` by default) and a board (initial board\n\tby default). The board is represented by an array of two integers and a string:\n\t`[rows, columns, string]`. The string must have:\n\n\t+ `'W'` for every square occupied by a white piece.\n\t+ `'B'` for every square occupied by a black piece.\n\t+ `'.'` for every empty square.\n\t*/\n\tconstructor: function Othello(activePlayer, board){\n\t\tGame.call(this, activePlayer);\n\t\tthis.board = this.makeBoard.apply(this, board || []);\n\t},\n\n\t/** `makeBoard(rows=8, columns=8, string)` is used to build the initial board.\n\t*/\n\t'dual makeBoard': function makeBoard(rows, columns, string){ //FIXME\n\t\trows = isNaN(rows) ? 8 : +rows;\n\t\tcolumns = isNaN(columns) ? 8 : +columns;\n\t\traiseIf(rows < 4 || columns < 4 || rows % 2 || columns % 2,\n\t\t\t\"An Reversi board must have even dimensions greater than 3.\");\n\t\tif (typeof string === 'string') {\n\t\t\treturn new CheckerboardFromString(rows, columns, string);\n\t\t} else {\n\t\t\treturn new CheckerboardFromString(rows, columns);\n\t\t}\n\t},\n\n\t/** The game is played by two players: Black and White. Black moves first.\n\t*/\n\tplayers: [\"Black\", \"White\"],\n\n\t/** Much of the move calculations are based on the possible lines in the board. These are\n\tcalculated and cached by the `lines(rows, cols)` function.\n\t*/\n\tlines: (function (cache) {\n\t\treturn function lines(rows, cols) {\n\t\t\tvar key = rows +'x'+ cols,\n\t\t\t\tresult = cache[key];\n\t\t\tif (typeof result === 'undefined') {\n\t\t\t\tresult = cache[key] = new Checkerboard(rows, cols).lines().map(function(line) {\n\t\t\t\t\treturn line.toArray();\n\t\t\t\t}, function(line){\n\t\t\t\t\treturn line.length > 2;\n\t\t\t\t}).toArray();\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t})({}),\n\n\t/** Another optimization in the move logic uses regular expressions to match patterns in the\n\tboard. These are predefined as a _class_ member.\n\t*/\n\t__MOVE_REGEXPS__: {\n\t\t\"Black\": [/\\.W+B/g, /BW+\\./g],\n\t\t\"White\": [/\\.B+W/g, /WB+\\./g]\n\t},\n\n\t/** The board's center is defined by the coordinates of the middle four squares.\n\t*/\n\t'dual boardCenter': function boardCenter(board) {\n\t\tboard = board || this.board;\n\t\tvar w = board.width,\n\t\t\th = board.height;\n\t\treturn [[h/2, w/2-1], [h/2-1, w/2], [h/2, w/2], [h/2-1, w/2-1]];\n\t},\n\n\t/** A move always places a piece in an empty square. If there are empty square at the center of\n\tthe board, the active player must place a piece in one of them. Else, a piece can be placed if\n\tand only if by doing so one or more lines of the opponent's pieces get enclosed between pieces\n\tof the active player.\n\t*/\n\tmoves: function moves(player){\n\t\tplayer = player || this.activePlayer();\n\t\tif (this.hasOwnProperty('__moves'+ player +'__')) {\n\t\t\treturn this['__moves'+ player +'__'];\n\t\t}\n\t\tvar board = this.board,\n\t\t\tcoords = {},\n\t\t\tregexps = this.__MOVE_REGEXPS__[player];\n\t\tvar _moves = this.boardCenter().filter(function (coord) {\n\t\t\t\treturn board.square(coord) === '.';\n\t\t\t});\n\t\tif (_moves.length < 1) {\n\t\t\tthis.lines(board.height, board.width).forEach(function(line){\n\t\t\t\tregexps.forEach(function (regexp) {\n\t\t\t\t\tboard.asString(line).replace(regexp, function(m, i){\n\t\t\t\t\t\tvar coord = m.charAt(0) === \".\" ? line[i] : line[m.length - 1 + i];\n\t\t\t\t\t\tcoords[coord] = coord;\n\t\t\t\t\t\treturn m;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t\tfor (var id in coords) {\n\t\t\t\t_moves.push(coords[id]);\n\t\t\t}\n\t\t}\n\t\t_moves = _moves.length > 0 ? obj(player, _moves) : null;\n\t\tif (arguments.length < 1) {\n\t\t\treturn this['__moves'+ player +'__'] = _moves; // Cache the result.\n\t\t}\n\t\treturn _moves;\n\t},\n\n\tvalidMoves: function validMoves(moves) {\n\t\tvar allMoves = this.moves();\n\t\tfor (var player in allMoves) {\n\t\t\tif (!moves.hasOwnProperty(player)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar validMove = allMoves[player].join('\\n').indexOf(moves[player] +'') >= 0;\n\t\t\tif (!validMove) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\t/** When the active player encloses one or more lines of opponent's pieces between two of its\n\town, all those are turned into active player's pieces.\n\t*/\n\tnext: function next(moves, haps, update) {\n\t\traiseIf(haps, 'Haps are not required (given ', haps, ')!');\n\t\tif (!this.validMoves(moves)) {\n\t\t\traise(\"Invalid moves \"+ JSON.stringify(moves) +\"!\");\n\t\t}\n\t\tvar board = this.board.clone(),\n\t\t\tactivePlayer = this.activePlayer(),\n\t\t\tmove = moves[activePlayer],\n\t\t\tpiece, valid;\n\t\tif (activePlayer == this.players[0]) {\n\t\t\tpiece = \"B\";\n\t\t\tvalid = /^W+B/;\n\t\t} else {\n\t\t\tpiece = \"W\";\n\t\t\tvalid = /^B+W/;\n\t\t}\n\t\tif (this.boardCenter().join('\\n').indexOf(move +'') >= 0) { // Place piece at center.\n\t\t\tboard.__place__(move, piece);\n\t\t} else {\n\t\t\tboard.walks(move, Checkerboard.DIRECTIONS.EVERY).forEach(function (walk){\n\t\t\t\tvar match = valid.exec(board.asString(walk).substr(1));\n\t\t\t\tif (match){\n\t\t\t\t\twalk.toArray().slice(0, match[0].length).forEach(function(coord){\n\t\t\t\t\t\tboard.__place__(coord, piece);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (update) {\n\t\t\tthis.constructor(this.opponent(), [board.height, board.width, board.string]);\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new this.constructor(this.opponent(), [board.height, board.width, board.string]);\n\t\t}\n\t},\n\n\t/** A match ends when the active player cannot move. The winner is the one with more pieces of\n\tits color in the board at the end.\n\t*/\n\tresult: function result() {\n\t\tif (this.moves()) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tvar weight = {\"W\": -1, \"B\": 1},\n\t\t\t\tres_b = iterable(this.board.string).map(function(m){\n\t\t\t\t\treturn weight[m] || 0;\n\t\t\t\t}).sum();\n\t\t\treturn this.zerosumResult(res_b, \"Black\");\n\t\t}\n\t},\n\n\t/** The actual score is calculated as the difference in piece count. This means that the maximum\n\tvictory (maybe impossible) is to fill the board with pieces of only one colour.\n\t*/\n\tresultBounds: function resultBounds() {\n\t\tvar squareCount = this.board.width * this.board.height;\n\t\treturn [-squareCount, +squareCount];\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** The game state serialization simply contains the constructor arguments.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: exports.__package__ +'.Reversi',\n\t\tserializer: function serialize_Reversi(obj) {\n\t\t\treturn [obj.activePlayer(), [obj.board.height, obj.board.width, obj.board.string]];\n\t\t}\n\t}\n}); // declare Reversi.\n\n/** Adding Reversi to `ludorum.games`.\n*/\nludorum.games.Reversi = Reversi;\n\n/** Sermat serialization.\n*/\nexports.__SERMAT__.include.push(Reversi);\n","/** # Othello\n\nImplementation of the [Othello variant of Reversi](http://www.worldothello.org/?q=content/reversi-versus-othello)\nfor Ludorum.\n*/\nvar Othello = exports.Othello = declare(Reversi, {\n\tname: 'Reversi',\n\n\t/** One main difference between Reversi and Othello is that is a player has no moves, the turn\n\tpasses to the other player. A match ends only when both players cannot move.\n\t*/\n\tconstructor: function Othello(activePlayer, board){\n\t\tReversi.call(this, activePlayer, board);\n\t\tif (!this.moves()) {\n\t\t\tvar opponent = this.opponent();\n\t\t\tif (this.moves(opponent)) {\n\t\t\t\tthis.activePlayers = [opponent];\n\t\t\t}\n\t\t}\n\t},\n\n\t/** `makeBoard(rows=8, columns=8, string)` is used to build the initial board. The starting\n\tboard of Othello is not empty, like Reversi. The four center squares are defined.\n\t*/\n\t'dual makeBoard': function makeBoard(rows, columns, string){\n\t\trows = isNaN(rows) ? 8 : +rows;\n\t\tcolumns = isNaN(columns) ? 8 : +columns;\n\t\traiseIf(rows < 4 || columns < 4 || rows % 2 || columns % 2,\n\t\t\t\"An Othello board must have even dimensions greater than 3.\");\n\t\tif (typeof string === 'string') {\n\t\t\treturn new CheckerboardFromString(rows, columns, string);\n\t\t} else {\n\t\t\treturn new CheckerboardFromString(rows, columns)\n\t\t\t\t.__place__([rows / 2, columns / 2 - 1], \"W\")\n\t\t\t\t.__place__([rows / 2 - 1, columns / 2], \"W\")\n\t\t\t\t.__place__([rows / 2, columns / 2], \"B\")\n\t\t\t\t.__place__([rows / 2 - 1, columns / 2 - 1], \"B\");\n\t\t}\n\t},\n\n\t// ## Utility methods ##########################################################################\n\n\t/** The game state serialization simply contains the constructor arguments.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: exports.__package__ +'.Othello',\n\t\tserializer: function serialize_Othello(obj) {\n\t\t\treturn [obj.activePlayer(), [obj.board.height, obj.board.width, obj.board.string]];\n\t\t}\n\t}\n}); // declare Othello.\n\n/** Adding Othello to `ludorum.games`.\n*/\nludorum.games.Othello = Othello;\n\n/** Sermat serialization.\n*/\nexports.__SERMAT__.include.push(Othello);\n","/** # Heuristics for Mancala\n\n`Othello.heuristics` is a bundle of helper functions to build heuristic evaluation functions for\nthis game.\n*/\nvar heuristics = exports.heuristics = {\n\t/** `heuristicFromWeights(weights)` returns an heuristic function that may be used with any\n\theuristic based player. Weights are normalized, so the result is in (-1,+1) (exclusively).\n\t*/\n\theuristicFromWeights: function heuristicFromWeights(weights) {\n\t\tvar weightCount = weights.length,\n\t\t\tweightSum = iterable(weights).map(Math.abs).sum(); // Used to normalize the sum.\n\t\tvar heuristic = function __heuristic__(game, player) {\n\t\t\tvar board = game.board;\n\t\t\traiseIf(board.height * board.width !== weightCount, \"Wrong amount of weights!\");\n\t\t\treturn board.weightedSum(weights, {\n\t\t\t\t'W': player.charAt(0) === 'W' ? 1 : -1,\n\t\t\t\t'B': player.charAt(0) === 'B' ? 1 : -1\n\t\t\t}) / weightSum;\n\t\t};\n\t\theuristic.weights = weights;\n\t\treturn heuristic;\n\t},\n\n\t/** `heuristicFromSymmetricWeights(weights)` is similar to `heuristicFromWeights()` but\n\tinstead of demanding a weight for every square in the board, it uses only the upper left\n\tquadrant and builds the rest by symmetry. Hence only a quarter of the weights is required.\n\t*/\n\theuristicFromSymmetricWeights: function heuristicFromSymmetricWeights(weights, rows, columns) {\n\t\trows = isNaN(rows) ? 8 : rows | 0;\n\t\tcolumns = isNaN(columns) ? 8 : columns | 0;\n\t\tvar width = Math.ceil(rows / 2);\n\t\traiseIf(width * Math.ceil(columns / 2) > weights.length, \"Not enough weights!\");\n\t\tweights = Iterable.range(columns).map(function (column) {\n\t\t\tvar i = column < columns / 2 ? column : columns - column - 1,\n\t\t\t\tleft = i * width,\n\t\t\t\tright = (i + 1) * width;\n\t\t\treturn weights.slice(left, right)\n\t\t\t\t.concat(weights.slice(left, right - rows % 2).reverse());\n\t\t}).flatten().toArray();\n\t\treturn this.heuristicFromWeights(weights);\n\t},\n\n\t/** `pieceRatio(game, player)` is an heuristic criteria based on the difference of the piece\n\tcounts of both players.\n\t*/\n\tpieceRatio: function pieceRatio(game, player) {\n\t\tvar playerPieceCount = 0, opponentPieceCount = 0;\n\t\titerable(game.board.string).forEach(function (sq) {\n\t\t\tif (sq !== '.') {\n\t\t\t\tif (sq === player.charAt(0)) {\n\t\t\t\t\t++playerPieceCount;\n\t\t\t\t} else {\n\t\t\t\t\t++opponentPieceCount;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn (playerPieceCount - opponentPieceCount) / (playerPieceCount + opponentPieceCount) || 0;\n\t},\n\n\t/** `mobilityRatio(game, player)` is an heuristic criteria based on the difference of the\n\tmove counts of both players.\n\t*/\n\tmobilityRatio: function mobilityRatio(game, player) {\n\t\tvar opponent = game.opponent(player),\n\t\t\tplayerMoves = game.moves(player),\n\t\t\topponentMoves = game.moves(opponent),\n\t\t\tplayerMoveCount = playerMoves && playerMoves[player] && playerMoves[player].length || 0,\n\t\t\topponentMoveCount = opponentMoves && opponentMoves[opponent] && opponentMoves[opponent].length || 0;\n\t\treturn (playerMoveCount - opponentMoveCount) / (playerMoveCount + opponentMoveCount) || 0;\n\t}\n};\n\n/** The default heuristic combines piece and mobility ratios with weights that ponder corners and\nborders but penalizes the squares next to the corners.\n*/\nheuristics.defaultHeuristic = ludorum.players.HeuristicPlayer.composite(\n\theuristics.heuristicFromSymmetricWeights(\n\t\t[+9,-3,+3,+3, -3,-3,-1,-1, +3,-1,+1,+1, +3,-1,+1,+1]\n\t), 0.6,\n\theuristics.pieceRatio, 0.2,\n\theuristics.mobilityRatio, 0.2\n);\n","// See __prologue__.js\n\tSermat.include(exports);\n\t\n\treturn exports;\n}\n"]}